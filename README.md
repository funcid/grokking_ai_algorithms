# Читаю "Грокаем Алгоритмы ИИ"

<details>
  <summary>стр. 114-149: <a href="./genetic_algorithm/src/main/kotlin/GeneticAlgorithm.ipynb">Эволюционный алгоритм</a>
</summary>

```
В данной задаче реализуется генетический алгоритм для решения классической 
задачи о рюкзаке. Цель — найти такую комбинацию предметов, чтобы их 
суммарная ценность была максимальной, а суммарный вес не превышал заданную 
грузоподъёмность рюкзака. Каждый предмет характеризуется весом и ценностью. 
Алгоритм начинается с генерации случайной популяции возможных решений (хромосом), 
каждая из которых представляет собой набор предметов. Далее для каждой хромосомы 
рассчитывается её приспособленность (fitness), определяемая как суммарная 
ценность выбранных предметов, если их общий вес не превышает ограничение. 
Алгоритм проходит через несколько поколений, применяя отбор, кроссовер и мутацию, 
постепенно улучшая решения. Визуализация показывает, как меняется приспособленность 
особей с течением поколений: синие точки отображают приспособленность всех 
особей, а красная линия показывает среднюю приспособленность на каждом шаге 
эволюции, что позволяет наблюдать общий прогресс алгоритма.

Интересное: поигрался с параметрами, не думал что мутация так сильно решает,
если ее выставить менее 80% - все будет плохо, кроссовер - крутая тема.
```

</details>

<details>
  <summary>стр. 171-204: <a href="./ant_algorithm/src/main/kotlin/AntAlgorithm.ipynb">Роевой интеллект:
муравьи</a>
    </summary>

```
В этой части я реализую муравьиный алгоритм — метод оптимизации, вдохновлённый 
поведением реальных муравьёв при поиске кратчайшего пути к источнику пищи. 
Алгоритм особенно хорошо подходит для задач коммивояжёра, поиска маршрутов и 
других комбинаторных задач. В качестве практической задачи рассматривается 
планирование оптимального маршрута по парку развлечений Диснейленд, чтобы 
минимизировать общее время ожидания в очередях. Для этого я использую актуальные 
данные с сайта queue-times.com, который предоставляет информацию о текущем 
времени ожидания на аттракционы. Каждый «муравей» в алгоритме будет 
моделировать посетителя парка, пытающегося найти лучший маршрут по 
аттракционам с учётом текущей загруженности. Муравьи будут оставлять 
виртуальные феромоны на маршрутах, которые приводят к более короткому 
времени ожидания, тем самым усиливая привлекательность удачных путей для 
последующих агентов. Таким образом, цель алгоритма — найти наиболее 
выгодную последовательность посещения аттракционов, которая минимизирует 
время в очередях и делает пребывание в парке 
максимально эффективным и комфортным.

Интересное: не знаю как можно учесть время ожидания в очереди,
оно не влияет на оптимальный маршрут. Возможно нужно задать
стоимость аттракциона и лимит по времени, но это буквально
генетический алгоритм + муравьиный алгоритм 
```

</details>

<details>
  <summary>стр. 206-237: <a href="./swarm_algorithm/src/main/kotlin/SwarmAlgorithm.ipynb">Роевой интеллект:
частицы</a>
  </summary>

```
Реализую алгоритм роя частиц (Particle Swarm Optimization, PSO) — 
метод оптимизации, вдохновлённый коллективным поведением стай птиц и косяков рыб. 
В отличие от муравьиного алгоритма, где агенты обмениваются информацией 
через феромоны, здесь частицы (агенты) взаимодействуют друг с другом 
напрямую, обновляя свои скорости и позиции на основе как собственного опыта, 
так и успехов соседей. Каждая частица помнит лучшее решение, которое она нашла, 
а также знает лучшее решение в своём окружении (или во всей популяции, 
в зависимости от варианта алгоритма). Практическая задача — минимизация сложной 
математической функции с множеством локальных минимумов. Частицы «летают» 
по пространству решений, со временем сближаясь к глобальному минимуму. 
Для визуализации я использовал двухмерную функцию с рельефной поверхностью, 
по которой можно наблюдать, как частицы постепенно сходятся к наиболее 
выгодной точке. Я также визуализировал траектории движения частиц, чтобы 
отследить, насколько сильно на них влияют собственные открытия и находки других.

Интересное: PSO оказался удивительно устойчивым к локальным минимумам.

```

</details>

<details>
  <summary>стр. 241-291: <a href="./machine_learning/src/main/kotlin/MachineLearning.ipynb">Машинное
обучение</a>
  </summary>

```
В этом разделе реализованы две базовые модели машинного обучения: линейная 
регрессия и метод k-ближайших соседей (k-NN). Линейная регрессия используется 
для предсказания числовых значений, при этом коэффициенты подбираются аналитически 
через метод наименьших квадратов. Метод k-NN применяется для классификации объектов 
на основе их близости к точкам из обучающей выборки: для нового элемента 
определяется k ближайших соседей, и класс выбирается большинством голосов.

Интересное: изменение значения k сильно влияет на результат — при слишком 
малых значениях алгоритм становится шумочувствительным, а при слишком больших 
— сглаживает различия. Линейная регрессия приятно удивила своей точностью, 
даже при простой реализации.

Интересное: Как-то неинтересно). Будто из данных формируем обобщения, которые
потом просто переиспользуем, разве абстракция это интеллект? Надо подумать

```

</details>
